#+OPTIONS: toc:nil
#+DESCRIPTION: This file is for recording what I do every day during the project.
* <2017-12-11 Mon>
** Read [[file:Document/%E3%80%8A%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CPU%E3%80%8BP1-300.pdf][《自己动手写CPU》 Chapter1]]
Knew some important conceptions.
* <2017-12-12 Tue>
** Read [[file:Document/%E3%80%8A%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CPU%E3%80%8BP1-300.pdf][《自己动手写CPU》 Chapter2]]
*** Reviewed the grammar of verilog.
*** Question: Why does rom[1] have to be 32'h01010101?
It's just an input which represents an instruction, and you can input whatever you want as long as it is a 32-bit hexadecimal.
** Read [[file:Document/%E3%80%8A%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CPU%E3%80%8BP1-300.pdf][《自己动手写CPU》 Chapter3]]
*** Finally I began to know the outline of what I needed to do. Especially [[file:Document/%E3%80%8A%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CPU%E3%80%8BP1-300.pdf::68][Figure 3-5 on Page 54]].
*** Question: What does the time signal "clk" do?
Kaiyi Zhang told me that I could regard it as a tool to out put the time signal to debug, and it fuctions like a stage.
*** Question: What does the reset signal "rst" do?
Kaiyi Zhang told me that I could use the signal to reset the module for stopping some process.
** Read [[file:Document/%E3%80%8A%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CPU%E3%80%8BP1-300.pdf][《自己动手写CPU》 Chapter4]]
*** Question: After I implement the ori module, how could I combine the module with the other to make the CPU complete?
First, I thought I could use a big module with many "if", and a spceific instruction corresponds with a specific module. But Kaiyi Zhang told me it was too complex. I should just combine all similar fuctions in a single module. An example for this is ALU, which can deal with all operations.
*** An problem from Kaiyi Zhang(On [[file:Document/%E3%80%8A%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CPU%E3%80%8BP1-300.pdf::111][Use data forwarding to deal with load instructions]]): When you read or write a memory or address, you have 2 stages' latency, which requires you to keep the read/write signal streamming.
*** The standard codes didn't pass compilation on my computer. 
* <2017-12-13 Wed>
** Read [[file:Document/%E3%80%8A%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CPU%E3%80%8BP1-300.pdf][《自己动手写CPU》 Chapter4]]
*** Implemented the instruction ORI.
I could try to implement the ori code myself referring to the standard codes on [[file:Document/%E3%80%8A%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CPU%E3%80%8BP1-300.pdf][《自己动手写CPU》 Chapter4]], which is simplest, and after that, what I need to do is to supplement some codes.
**** I learnt how to use macros like fuctions in verilog. 
**** Problems in my codes:
+ Codes passed compilation, but took about 10 minutes.
+ Codes couldn't run normally.
 [[file:Picture/2017-12-14%2001-19-40%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png][Screenshot while Running]]
** Read [[file:Document/%E3%80%8A%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CPU%E3%80%8BP1-300.pdf][《自己动手写CPU》 Chapter5]]
*** Knew what kind of problems I would meet in the future.
* <2017-12-14 Thu>
** Read [[file:Document/%E3%80%8A%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CPU%E3%80%8BP1-300.pdf][《自己动手写CPU》 Chapter4]]
*** Made my codes run normally with Kaiyi Zhang's help.
[[file:Picture/2017-12-14%2020-46-57%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png][Screenshot]]
****  Modified the depth of "inst_mem" in [[file:Source/Chapter%204/inst_rom.v::13][inst_rom.v]] from `InstMemNum-1 to 3. 
Not only I didn't had the warning "Not enough words in the file" as the fuction ~$readmemh~ would read the depth of "inst_mem" hexadecimal numbers in [[file:Source/Chapter%204/inst_rom.data][inst_rom.data]], but also the time for compilation was much shortened.
**** Changed the function ~$stop~ in [[file:Source/Chapter%204/openmips_min_sopc_tb.v][openmips_min_sopc_tb.v]] to ~$finish~ so that VVP could be dismissed and also added the timescale in  [[file:Source/Chapter%204/openmips_min_sopc_tb.v:5][openmips_min_sopc_tb.v]].
*** Question: Why did my data flush so slowly?
** Read [[file:Document/%E3%80%8A%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CPU%E3%80%8BP1-300.pdf][《自己动手写CPU》 Chapter5]]
*** Added data forwarding.
*** Transformed my instruction sets from mips to risc-v.
* <2017-12-15 Fri>
** Read [[file:Document/%E3%80%8A%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CPU%E3%80%8BP1-300.pdf][《自己动手写CPU》 Chapter5]]
*** Added instructions: AND ANDI OR XOR XORI LUI SLL SLLI SRA SRAI SRL SRLI. But all were to be tested.
*** Question: How did ~shiftres <= ({32{reg2_i[31]}} << (6'd32-{1'b0, reg1_i[4:0]}))| reg2_i >> reg1_i[4:0];~ implemented arithmetic left shift?
* <2017-12-16 Sat>
** Tested all the logic instructions.
** Downloaded the [[https://github.com/riscv/riscv-gnu-toolchain][GNU toolchain for RISC-V, including GCC(Newlib)]](this could helpe you generate test instructions) but failed.
* <2017-12-17 Sun>
** Installed the gun risc toolchain for almost all day.
*** Clone the toolchain locally.
**** If you could climb over the wall:
Run the following codes:
#+BEGIN_SRC sh
  $ git clone --recursive https://github.com/riscv/riscv-gnu-toolchain
#+END_SRC
or alternatively:
#+BEGIN_SRC sh
  $ git clone https://github.com/riscv/riscv-gnu-toolchain
  $ cd riscv-gnu-toolchain
  $ git submodule update --init --recursive
#+END_SRC
The source codes are somewhat large, please wait patient.
**** If you couldn't climb over the wall:
Download the package at [[https://jbox.sjtu.edu.cn/link/view/8971e3226df74d35b2dcbe588397958f]]. Remember to depackage with the command:
#+BEGIN_SRC sh
  tar -zxvf riscv-gnu-toolchain.tar.gz
#+END_SRC
If you use git directly, maybe you couldn't clone all source codes which may cause that your toolchain cannot work normally.
*** Make the source code.
Run the following command to get riscv32.
#+BEGIN_SRC sh
  ./configure --prefix=/opt/riscv --with-arch=rv32gc --with-abi=ilp32d
  make
#+END_SRC
*** Modify your path variable.
First run the command
#+BEGIN_SRC sh
  sudo gedit /etc/profile
#+END_SRC
Then add
#+BEGIN_SRC sh
  export PATH="$PATH:/opt/riscv/bin"
#+END_SRC
*** Tranform the assembly to riscv instructions.
Use the following command
#+BEGIN_SRC sh
  riscv32-unknown-elf-as -o $1.o -march=rv32i $1.s 
  riscv32-unknown-elf-ld $1.o -o $1.om
  riscv32-unknown-elf-objcopy -O binary $1.om $1.bin
  ../../Tools/Bin_to_Text $1.bin > instr.data
  rm $1.o $1.om $1.bin
#+END_SRC
which was included in [[file:Tools/get_instr.sh][get_instr.sh]]. You need run the bash with exactly one parament which shows that your assembly source code's name is "$1.s". And you will get an file named instr.data which contains your hexadecimal riscv32 instructions. Attention: Please modify the path of ~Bin_to_Text~ according to your current directory.
** Tried to transform a binary file to a text file.
The source code was [[Tools/Bin_to_Text.cpp][Bin_to_Text.cpp]].
** Question: How to write riscv assembly correctly?



